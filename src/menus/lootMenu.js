/**
 * Loot Menu
 * Allows player to loot cargo from defeated enemy ships
 */

const LootMenu = (() => {
    let gameState = null;
    let selectedCargoIndex = 0;
    let outputMessage = '';
    let outputColor = COLORS.TEXT_NORMAL;
    let lootCargo = {}; // Combined cargo from all enemy ships
    let creditReward = 0; // One-time credit reward
    let mode = 'loot'; // 'loot', 'modules', 'select-module-ship'
    let pendingModules = [];
    let selectedModuleIndex = 0;
    let selectedModuleShipIndex = 0;
    let selectedModule = null;
    
    /**
     * Show the loot menu
     * @param {GameState} state - Current game state
     * @param {Array<Ship>} defeatedShips - Array of defeated enemy ships
     * @param {Object} encounterType - The encounter type for credit rewards
     * @param {Function} onContinue - Callback when player continues journey
     */
    function show(state, defeatedShips, encounterType, onContinue) {
        gameState = state;
        selectedCargoIndex = 0;
        outputMessage = '';
        
        // Combine cargo from all defeated ships
        lootCargo = {};
        defeatedShips.forEach(ship => {
            for (const cargoId in ship.cargo) {
                const amount = ship.cargo[cargoId];
                if (amount > 0) {
                    lootCargo[cargoId] = (lootCargo[cargoId] || 0) + amount;
                }
            }
        });
        
        // Calculate credit reward (random between 1 and maxCredits, or 0 if maxCredits is 0)
        creditReward = encounterType.maxCredits === 0 ? 0 : Math.floor(Math.random() * encounterType.maxCredits) + 1;
        
        // Award credits immediately
        gameState.credits += creditReward;
        
        // Determine module drops (generated by EncounterGenerator)
        const shipModules = Array.isArray(gameState.encounterShipModules)
            ? [...gameState.encounterShipModules]
            : (Array.isArray(encounterType.shipModules) ? [...encounterType.shipModules] : []);
        
        pendingModules = shipModules;
        selectedModuleIndex = 0;
        selectedModuleShipIndex = 0;
        selectedModule = null;
        mode = pendingModules.length > 0 ? 'modules' : 'loot';
        
        UI.resetSelection();
        render(onContinue);
    }

    /**
     * Get maximum modules allowed per ship based on engineering perks
     */
    function getMaxModulesAllowed() {
        if (gameState.perks && gameState.perks.has('ENGINEERING_III')) return 3;
        if (gameState.perks && gameState.perks.has('ENGINEERING_II')) return 2;
        if (gameState.perks && gameState.perks.has('ENGINEERING_I')) return 1;
        return 0;
    }
    
    /**
     * Render the loot screen
     */
    function render(onContinue) {
        UI.clear();
        
        const grid = UI.getGridSize();
        
        if (mode === 'modules') {
            renderModuleInstall(onContinue, grid);
            return;
        }
        if (mode === 'select-module-ship') {
            renderSelectModuleShip(onContinue, grid);
            return;
        }
        
        // Title
        UI.addTitleLineCentered(0, 'Victory: Salvage Operations');
        
        // Credits awarded (only show if credits were actually found)
        if (creditReward > 0) {
            UI.addText(5, 5, `Credits found: +${creditReward} CR`, COLORS.GREEN);
        }

        if (gameState.factionReward) {
            if (gameState.factionReward.type === 'credits') {
                UI.addText(5, 6, `Faction reward: +${gameState.factionReward.amount} CR`, COLORS.GREEN);
            } else if (gameState.factionReward.type === 'loot') {
                const rewardItems = Object.entries(gameState.factionReward.cargo)
                    .filter(([, amount]) => amount > 0)
                    .map(([cargoId, amount]) => `${amount} ${CARGO_TYPES[cargoId]?.name || cargoId}`);
                if (rewardItems.length > 0) {
                    UI.addText(5, 6, `Faction reward: ${rewardItems.join(', ')}`, COLORS.GREEN);
                }
            }
            gameState.factionReward = null;
        }
        
        // Player cargo info
        const fleetCargo = Ship.getFleetCargo(gameState.ships);
        const totalPlayerCargo = Object.values(fleetCargo).reduce((sum, amt) => sum + amt, 0);
        const totalPlayerCapacity = gameState.ships.reduce((sum, ship) => sum + ship.cargoCapacity, 0);
        UI.addText(5, 7, `Your Cargo: ${totalPlayerCargo} / ${totalPlayerCapacity}`, COLORS.TEXT_NORMAL);
        
        // Check if there's any loot
        const hasLoot = Object.keys(lootCargo).length > 0;
        
        if (!hasLoot) {
            UI.addText(5, 9, 'No cargo found on enemy ships.', COLORS.TEXT_DIM);
            
            const buttonY = grid.height - 4;
            UI.addButton(5, buttonY, '0', 'Continue Journey', onContinue, COLORS.GREEN);
            
            if (outputMessage) {
                UI.setOutputRow(outputMessage, outputColor);
            }
            
            UI.draw();
            return;
        }
        
        // Loot table - show all enabled cargo types (don't filter by loot amount)
        const startY = 10;
        const rows = ALL_CARGO_TYPES
            .filter(cargoType => gameState.enabledCargoTypes.some(ct => ct.id === cargoType.id))
            .map((cargoType, index) => {
                const lootQuantity = lootCargo[cargoType.id] || 0;
                const playerQuantity = fleetCargo[cargoType.id] || 0;
                
                return [
                    { text: cargoType.name, color: COLORS.TEXT_NORMAL },
                    { text: String(playerQuantity), color: COLORS.TEXT_NORMAL },
                    { text: String(lootQuantity), color: COLORS.TEXT_NORMAL }
                ];
            });
        
        // Ensure selectedCargoIndex is valid
        if (selectedCargoIndex >= rows.length) {
            selectedCargoIndex = Math.max(0, rows.length - 1);
        }
        
        TableRenderer.renderTable(5, startY, ['Cargo Type', 'Your Cargo', 'Available'], rows, selectedCargoIndex, 2, (rowIndex) => {
            // When a row is clicked, select that cargo
            selectedCargoIndex = rowIndex;
            outputMessage = '';
            render(onContinue);
        });
        
        // Buttons
        const buttonY = grid.height - 4;
        
        // Get selected cargo type and check training
        const availableCargoTypes = ALL_CARGO_TYPES.filter(ct => 
            gameState.enabledCargoTypes.some(ect => ect.id === ct.id)
        );
        const selectedCargoType = availableCargoTypes[selectedCargoIndex];
        const lootQuantity = selectedCargoType ? (lootCargo[selectedCargoType.id] || 0) : 0;
        const playerQuantity = selectedCargoType ? (fleetCargo[selectedCargoType.id] || 0) : 0;
        const availableSpace = Ship.getFleetAvailableCargoSpace(gameState.ships);
        
        // Check if this cargo type is enabled (player has training for it)
        const hasTraining = selectedCargoType ? gameState.enabledCargoTypes.some(ct => ct.id === selectedCargoType.id) : false;
        
        // Build help text for Take buttons
        let take1HelpText = 'Take 1 unit of selected cargo';
        let take10HelpText = 'Take 10 units of selected cargo';
        if (lootQuantity === 0) {
            take1HelpText = 'No cargo available';
            take10HelpText = 'No cargo available';
        } else if (availableSpace === 0) {
            take1HelpText = 'No cargo space available';
            take10HelpText = 'No cargo space available';
        }
        
        // Build help text for Dump buttons
        let dump1HelpText = 'Dump 1 unit of selected cargo from your fleet into space';
        let dump10HelpText = 'Dump 10 units of selected cargo from your fleet into space';
        if (playerQuantity === 0) {
            dump1HelpText = 'No cargo in your fleet to dump';
            dump10HelpText = 'No cargo in your fleet to dump';
        }
        
        // Navigation buttons
        UI.addButton(5, buttonY, '1', 'Previous Cargo', () => prevCargo(onContinue), COLORS.BUTTON, 'Select previous cargo type');
        UI.addButton(5, buttonY + 1, '2', 'Next Cargo', () => nextCargo(onContinue), COLORS.BUTTON, 'Select next cargo type');
        
        // Take buttons - gray out if no training, no loot, or no space
        const canTake = hasTraining && lootQuantity > 0 && availableSpace > 0;
        const takeColor = canTake ? COLORS.GREEN : COLORS.TEXT_DIM;
        UI.addButton(25, buttonY, '3', 'Take 1', () => takeCargo(1, onContinue), takeColor, take1HelpText);
        UI.addButton(25, buttonY + 1, '4', 'Take 10', () => takeCargo(10, onContinue), takeColor, take10HelpText);
        
        // Dump buttons - gray out if player has no cargo
        const canDump = playerQuantity > 0;
        const dumpColor = canDump ? COLORS.TEXT_ERROR : COLORS.TEXT_DIM;
        UI.addButton(45, buttonY, '5', 'Dump 1', () => dumpCargo(1, onContinue), dumpColor, dump1HelpText);
        UI.addButton(45, buttonY + 1, '6', 'Dump 10', () => dumpCargo(10, onContinue), dumpColor, dump10HelpText);
        
        UI.addButton(5, buttonY + 2, '0', 'Continue Journey', onContinue, COLORS.BUTTON);
        
        // Set output message in UI output row system if there's a message
        if (outputMessage) {
            UI.setOutputRow(outputMessage, outputColor);
        }
        
        UI.draw();
    }

    /**
     * Render alien module installation screen
     */
    function renderModuleInstall(onContinue, grid) {
        UI.addTitleLineCentered(0, 'Recovered Alien Technology');
        UI.addText(5, 4, 'Recovered Modules:', COLORS.TEXT_NORMAL);

        const startY = 6;
        const rows = pendingModules.map((moduleId) => {
            const module = SHIP_MODULES[moduleId];
            return [
                { text: module.name, color: COLORS.TEXT_NORMAL },
                { text: module.description, color: COLORS.TEXT_DIM }
            ];
        });

        // Ensure selectedModuleIndex is valid
        if (selectedModuleIndex >= rows.length) {
            selectedModuleIndex = Math.max(0, rows.length - 1);
        }

        TableRenderer.renderTable(5, startY, ['Module', 'Effect'], rows, selectedModuleIndex, 2, (rowIndex) => {
            selectedModuleIndex = rowIndex;
            outputMessage = '';
            render(onContinue);
        });

        const buttonY = grid.height - 4;

        if (pendingModules.length > 1) {
            UI.addButton(5, buttonY, '1', 'Next Module', () => {
                selectedModuleIndex = (selectedModuleIndex + 1) % pendingModules.length;
                outputMessage = '';
                render(onContinue);
            }, COLORS.BUTTON, 'Select next module');
            UI.addButton(5, buttonY + 1, '2', 'Prev Module', () => {
                selectedModuleIndex = (selectedModuleIndex - 1 + pendingModules.length) % pendingModules.length;
                outputMessage = '';
                render(onContinue);
            }, COLORS.BUTTON, 'Select previous module');
        }

        UI.addButton(28, buttonY, '3', 'Install on Ship', () => initiateModuleInstall(onContinue), COLORS.GREEN, 'Choose a ship to install this module');
        UI.addButton(28, buttonY + 1, '0', 'Skip Installation', () => skipModuleInstall(onContinue), COLORS.BUTTON, 'Proceed to salvage without installing');

        if (outputMessage) {
            UI.setOutputRow(outputMessage, outputColor);
        }

        UI.draw();
    }

    /**
     * Render ship selection for module install
     */
    function renderSelectModuleShip(onContinue, grid) {
        UI.addTitleLineCentered(0, 'Install Alien Module');
        UI.addText(5, 4, `Select ship to install ${selectedModule.name}:`, COLORS.YELLOW);
        const maxModulesAllowed = Math.min(SHIP_MAX_NUM_MODULES, getMaxModulesAllowed());

        const startY = 6;
        const rows = gameState.ships.map((ship) => {
            const shipType = SHIP_TYPES[ship.type] || { name: 'Unknown' };
            const numInstalledModules = ship.modules ? ship.modules.filter(m => m !== ship.defaultModule).length : 0;
            const canInstall = numInstalledModules < maxModulesAllowed;
            const statusText = canInstall ? `${numInstalledModules}/${maxModulesAllowed}` : 'FULL';
            const statusColor = canInstall ? COLORS.TEXT_NORMAL : COLORS.TEXT_ERROR;

            return [
                { text: shipType.name, color: canInstall ? COLORS.TEXT_NORMAL : COLORS.TEXT_DIM },
                { text: `${ship.hull}/${ship.maxHull}`, color: COLORS.TEXT_NORMAL },
                { text: String(ship.cargoCapacity), color: COLORS.TEXT_NORMAL },
                { text: statusText, color: statusColor }
            ];
        });

        TableRenderer.renderTable(5, startY, ['Type', 'Hull', 'Cargo', 'Modules'], rows, selectedModuleShipIndex, 2, (rowIndex) => {
            selectedModuleShipIndex = rowIndex;
            outputMessage = '';
            render(onContinue);
        });

        const buttonY = grid.height - 4;
        if (gameState.ships.length > 1) {
            UI.addButton(5, buttonY, '1', 'Next Ship', () => {
                selectedModuleShipIndex = (selectedModuleShipIndex + 1) % gameState.ships.length;
                outputMessage = '';
                render(onContinue);
            }, COLORS.BUTTON);
            UI.addButton(5, buttonY + 1, '2', 'Prev Ship', () => {
                selectedModuleShipIndex = (selectedModuleShipIndex - 1 + gameState.ships.length) % gameState.ships.length;
                outputMessage = '';
                render(onContinue);
            }, COLORS.BUTTON);
        }

        UI.addButton(28, buttonY, '3', 'Confirm Install', () => confirmModuleInstall(onContinue), COLORS.GREEN);
        UI.addButton(28, buttonY + 1, '0', 'Cancel', () => cancelModuleInstall(onContinue), COLORS.BUTTON);

        if (outputMessage) {
            UI.setOutputRow(outputMessage, outputColor);
        }

        UI.draw();
    }

    function initiateModuleInstall(onContinue) {
        if (pendingModules.length === 0) {
            outputMessage = 'No modules to install.';
            outputColor = COLORS.TEXT_ERROR;
            render(onContinue);
            return;
        }
        const moduleId = pendingModules[selectedModuleIndex];
        selectedModule = SHIP_MODULES[moduleId];
        mode = 'select-module-ship';
        selectedModuleShipIndex = 0;
        outputMessage = '';
        UI.resetSelection();
        render(onContinue);
    }

    function confirmModuleInstall(onContinue) {
        const ship = gameState.ships[selectedModuleShipIndex];
        const maxModulesAllowed = Math.min(SHIP_MAX_NUM_MODULES, getMaxModulesAllowed());
        const numInstalledModules = ship.modules ? ship.modules.filter(m => m !== ship.defaultModule).length : 0;
 
        if (numInstalledModules >= maxModulesAllowed) {
            outputMessage = `Ship already has maximum modules (${maxModulesAllowed})!`;
            outputColor = COLORS.TEXT_ERROR;
            render(onContinue);
            return;
        }

        if (ship.modules && ship.modules.includes(selectedModule.id)) {
            outputMessage = `Ship already has ${selectedModule.name} installed!`;
            outputColor = COLORS.TEXT_ERROR;
            render(onContinue);
            return;
        }

        if (!ship.modules) {
            ship.modules = [];
        }
        ship.modules.push(selectedModule.id);
        selectedModule.onInstall(ship);

        const shipType = SHIP_TYPES[ship.type] || { name: 'Ship' };
        outputMessage = `Installed ${selectedModule.name} on ${shipType.name}!`;
        outputColor = COLORS.TEXT_SUCCESS;

        pendingModules.splice(selectedModuleIndex, 1);
        selectedModule = null;
        selectedModuleShipIndex = 0;

        if (pendingModules.length === 0) {
            mode = 'loot';
        } else {
            mode = 'modules';
            selectedModuleIndex = Math.min(selectedModuleIndex, pendingModules.length - 1);
        }

        UI.resetSelection();
        render(onContinue);
    }

    function cancelModuleInstall(onContinue) {
        mode = 'modules';
        selectedModule = null;
        selectedModuleShipIndex = 0;
        outputMessage = '';
        UI.resetSelection();
        render(onContinue);
    }

    function skipModuleInstall(onContinue) {
        pendingModules = [];
        selectedModuleIndex = 0;
        selectedModuleShipIndex = 0;
        selectedModule = null;
        mode = 'loot';
        outputMessage = '';
        UI.resetSelection();
        render(onContinue);
    }
    
    /**
     * Take cargo from loot
     */
    function takeCargo(amount, onContinue) {
        // Get the selected cargo type from filtered list (only enabled cargo with loot)
        const availableCargoTypes = ALL_CARGO_TYPES.filter(ct => 
            lootCargo[ct.id] > 0 && gameState.enabledCargoTypes.some(ect => ect.id === ct.id)
        );
        if (selectedCargoIndex >= availableCargoTypes.length) {
            outputMessage = 'Invalid cargo selection.';
            outputColor = COLORS.TEXT_ERROR;
            render(onContinue);
            return;
        }
        
        const cargoType = availableCargoTypes[selectedCargoIndex];
        
        const availableLoot = lootCargo[cargoType.id] || 0;
        const availableSpace = Ship.getFleetAvailableCargoSpace(gameState.ships);
        
        // Adjust amount based on availability and space
        const actualAmount = Math.min(amount, availableLoot, availableSpace);
        
        if (actualAmount === 0) {
            if (availableLoot === 0) {
                outputMessage = 'No cargo available!';
            } else if (availableSpace === 0) {
                outputMessage = 'No cargo space available!';
            } else {
                outputMessage = 'Cannot take any cargo.';
            }
            outputColor = COLORS.TEXT_ERROR;
        } else {
            // Take the cargo
            lootCargo[cargoType.id] -= actualAmount;
            Ship.addCargoToFleet(gameState.ships, cargoType.id, actualAmount);
            
            const message = actualAmount < amount 
                ? `Took all ${actualAmount}x ${cargoType.name}!` 
                : `Took ${actualAmount}x ${cargoType.name}!`;
            outputMessage = message;
            outputColor = COLORS.TEXT_SUCCESS;
        }
        
        render(onContinue);
    }
    
    /**
     * Dump cargo from player fleet into loot
     */
    function dumpCargo(amount, onContinue) {
        // Get the selected cargo type from filtered list (all enabled cargo types)
        const availableCargoTypes = ALL_CARGO_TYPES.filter(ct => 
            gameState.enabledCargoTypes.some(ect => ect.id === ct.id)
        );
        if (selectedCargoIndex >= availableCargoTypes.length) {
            outputMessage = 'Invalid cargo selection.';
            outputColor = COLORS.TEXT_ERROR;
            render(onContinue);
            return;
        }
        
        const cargoType = availableCargoTypes[selectedCargoIndex];
        const fleetCargo = Ship.getFleetCargo(gameState.ships);
        const playerAmount = fleetCargo[cargoType.id] || 0;
        
        // Adjust amount based on what player has
        const actualAmount = Math.min(amount, playerAmount);
        
        if (actualAmount === 0) {
            outputMessage = 'No cargo to dump!';
            outputColor = COLORS.TEXT_ERROR;
        } else {
            // Remove cargo from player fleet
            Ship.removeCargoFromFleet(gameState.ships, cargoType.id, actualAmount);
            
            // Add to loot
            lootCargo[cargoType.id] = (lootCargo[cargoType.id] || 0) + actualAmount;
            
            const message = actualAmount < amount 
                ? `Dumped all ${actualAmount}x ${cargoType.name} into loot.` 
                : `Dumped ${actualAmount}x ${cargoType.name} into loot.`;
            outputMessage = message;
            outputColor = COLORS.TEXT_NORMAL;
        }
        
        render(onContinue);
    }
    
    /**
     * Select next cargo type (skip untrained cargo types)
     */
    function nextCargo(onContinue) {
        const availableCargoTypes = ALL_CARGO_TYPES.filter(ct => 
            gameState.enabledCargoTypes.some(ect => ect.id === ct.id)
        );
        
        const startIndex = selectedCargoIndex;
        do {
            selectedCargoIndex = (selectedCargoIndex + 1) % availableCargoTypes.length;
        } while (selectedCargoIndex !== startIndex && availableCargoTypes.length > 1);
        
        outputMessage = '';
        render(onContinue);
    }
    
    /**
     * Select previous cargo type (skip untrained cargo types)
     */
    function prevCargo(onContinue) {
        const availableCargoTypes = ALL_CARGO_TYPES.filter(ct => 
            gameState.enabledCargoTypes.some(ect => ect.id === ct.id)
        );
        
        const startIndex = selectedCargoIndex;
        do {
            selectedCargoIndex = (selectedCargoIndex - 1 + availableCargoTypes.length) % availableCargoTypes.length;
        } while (selectedCargoIndex !== startIndex && availableCargoTypes.length > 1);
        
        outputMessage = '';
        render(onContinue);
    }
    
    return {
        show
    };
})();
